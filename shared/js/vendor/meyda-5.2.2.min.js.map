{"version":3,"file":"meyda.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../../src/windowing.ts","../../../src/utilities.ts","../../../src/extractors/extractorUtilities.ts","../../../src/extractors/loudness.ts","../../../src/extractors/powerSpectrum.ts","../../node_modules/dct/src/dct.js","../../node_modules/dct/index.js","../../../src/featureExtractors.ts","../../../src/extractors/rms.ts","../../../src/extractors/energy.ts","../../../src/extractors/spectralSlope.ts","../../../src/extractors/spectralCentroid.ts","../../../src/extractors/spectralRolloff.ts","../../../src/extractors/spectralFlatness.ts","../../../src/extractors/spectralSpread.ts","../../../src/extractors/spectralSkewness.ts","../../../src/extractors/spectralKurtosis.ts","../../../src/extractors/zcr.ts","../../../src/extractors/perceptualSpread.ts","../../../src/extractors/perceptualSharpness.ts","../../../src/extractors/mfcc.ts","../../../src/extractors/chroma.ts","../../../src/extractors/spectralFlux.ts","../../node_modules/fftjs/dist/utils.js","../../node_modules/fftjs/dist/fft.js","../../../src/meyda-wa.ts","../../../src/main.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","export function blackman(size) {\n  let blackmanBuffer = new Float32Array(size);\n  let coeff1 = (2 * Math.PI) / (size - 1);\n  let coeff2 = 2 * coeff1;\n\n  //According to http://uk.mathworks.com/help/signal/ref/blackman.html\n  //first half of the window\n  for (let i = 0; i < size / 2; i++) {\n    blackmanBuffer[i] =\n      0.42 - 0.5 * Math.cos(i * coeff1) + 0.08 * Math.cos(i * coeff2);\n  }\n\n  //second half of the window\n  for (let i = Math.ceil(size / 2); i > 0; i--) {\n    blackmanBuffer[size - i] = blackmanBuffer[i - 1];\n  }\n\n  return blackmanBuffer;\n}\n\nexport function sine(size) {\n  let coeff = Math.PI / (size - 1);\n  let sineBuffer = new Float32Array(size);\n\n  for (let i = 0; i < size; i++) {\n    sineBuffer[i] = Math.sin(coeff * i);\n  }\n\n  return sineBuffer;\n}\n\nexport function hanning(size) {\n  let hanningBuffer = new Float32Array(size);\n  for (let i = 0; i < size; i++) {\n    // According to the R documentation\n    // http://ugrad.stat.ubc.ca/R/library/e1071/html/hanning.window.html\n    hanningBuffer[i] = 0.5 - 0.5 * Math.cos((2 * Math.PI * i) / (size - 1));\n  }\n\n  return hanningBuffer;\n}\n\nexport function hamming(size) {\n  let hammingBuffer = new Float32Array(size);\n  for (let i = 0; i < size; i++) {\n    //According to http://uk.mathworks.com/help/signal/ref/hamming.html\n    hammingBuffer[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * (i / size - 1));\n  }\n\n  return hammingBuffer;\n}\n","import * as windowing from \"./windowing\";\n\nlet windows = {};\n\nexport function isPowerOfTwo(num) {\n  while (num % 2 === 0 && num > 1) {\n    num /= 2;\n  }\n\n  return num === 1;\n}\n\nexport function error(message) {\n  throw new Error(\"Meyda: \" + message);\n}\n\nexport function pointwiseBufferMult(a, b) {\n  let c: number[] = [];\n  for (let i = 0; i < Math.min(a.length, b.length); i++) {\n    c[i] = a[i] * b[i];\n  }\n\n  return c;\n}\n\nexport function applyWindow(signal, windowname) {\n  if (windowname !== \"rect\") {\n    if (windowname === \"\" || !windowname) windowname = \"hanning\";\n    if (!windows[windowname]) windows[windowname] = {};\n\n    if (!windows[windowname][signal.length]) {\n      try {\n        windows[windowname][signal.length] = windowing[windowname](\n          signal.length\n        );\n      } catch (e) {\n        throw new Error(\"Invalid windowing function\");\n      }\n    }\n\n    signal = pointwiseBufferMult(signal, windows[windowname][signal.length]);\n  }\n\n  return signal;\n}\n\nexport function createBarkScale(length, sampleRate, bufferSize): Float32Array {\n  let barkScale = new Float32Array(length);\n\n  for (var i = 0; i < barkScale.length; i++) {\n    barkScale[i] = (i * sampleRate) / bufferSize;\n    barkScale[i] =\n      13 * Math.atan(barkScale[i] / 1315.8) +\n      3.5 * Math.atan(Math.pow(barkScale[i] / 7518, 2));\n  }\n\n  return barkScale;\n}\n\nexport function typedToArray(t) {\n  // utility to convert typed arrays to normal arrays\n  return Array.prototype.slice.call(t);\n}\n\nexport function arrayToTyped(t) {\n  // utility to convert arrays to typed F32 arrays\n  return Float32Array.from(t);\n}\n\nexport function _normalize(num, range) {\n  return num / range;\n}\n\nexport function normalize(a, range) {\n  return a.map(function (n) {\n    return _normalize(n, range);\n  });\n}\n\nexport function normalizeToOne(a) {\n  var max = Math.max.apply(null, a);\n\n  return a.map(function (n) {\n    return n / max;\n  });\n}\n\nexport function mean(a) {\n  return (\n    a.reduce(function (prev, cur) {\n      return prev + cur;\n    }) / a.length\n  );\n}\n\nfunction _melToFreq(melValue) {\n  var freqValue = 700 * (Math.exp(melValue / 1125) - 1);\n  return freqValue;\n}\n\nfunction _freqToMel(freqValue) {\n  var melValue = 1125 * Math.log(1 + freqValue / 700);\n  return melValue;\n}\n\nexport function melToFreq(mV) {\n  return _melToFreq(mV);\n}\n\nexport function freqToMel(fV) {\n  return _freqToMel(fV);\n}\n\nexport function createMelFilterBank(\n  numFilters: number,\n  sampleRate: number,\n  bufferSize: number\n): number[][] {\n  //the +2 is the upper and lower limits\n  let melValues = new Float32Array(numFilters + 2);\n  let melValuesInFreq = new Float32Array(numFilters + 2);\n\n  //Generate limits in Hz - from 0 to the nyquist.\n  let lowerLimitFreq = 0;\n  let upperLimitFreq = sampleRate / 2;\n\n  //Convert the limits to Mel\n  let lowerLimitMel = _freqToMel(lowerLimitFreq);\n  let upperLimitMel = _freqToMel(upperLimitFreq);\n\n  //Find the range\n  let range = upperLimitMel - lowerLimitMel;\n\n  //Find the range as part of the linear interpolation\n  let valueToAdd = range / (numFilters + 1);\n\n  let fftBinsOfFreq: number[] = new Array(numFilters + 2);\n\n  for (let i = 0; i < melValues.length; i++) {\n    // Initialising the mel frequencies\n    // They're a linear interpolation between the lower and upper limits.\n    melValues[i] = i * valueToAdd;\n\n    // Convert back to Hz\n    melValuesInFreq[i] = _melToFreq(melValues[i]);\n\n    // Find the corresponding bins\n    fftBinsOfFreq[i] = Math.floor(\n      ((bufferSize + 1) * melValuesInFreq[i]) / sampleRate\n    );\n  }\n\n  var filterBank: number[][] = new Array(numFilters);\n  for (let j = 0; j < filterBank.length; j++) {\n    // Create a two dimensional array of size numFilters * (buffersize/2)+1\n    // pre-populating the arrays with 0s.\n    filterBank[j] = new Array(bufferSize / 2 + 1).fill(0);\n\n    //creating the lower and upper slopes for each bin\n    for (let i = fftBinsOfFreq[j]; i < fftBinsOfFreq[j + 1]; i++) {\n      filterBank[j][i] =\n        (i - fftBinsOfFreq[j]) / (fftBinsOfFreq[j + 1] - fftBinsOfFreq[j]);\n    }\n\n    for (let i = fftBinsOfFreq[j + 1]; i < fftBinsOfFreq[j + 2]; i++) {\n      filterBank[j][i] =\n        (fftBinsOfFreq[j + 2] - i) /\n        (fftBinsOfFreq[j + 2] - fftBinsOfFreq[j + 1]);\n    }\n  }\n\n  return filterBank;\n}\n\nexport function hzToOctaves(freq, A440) {\n  return Math.log2((16 * freq) / A440);\n}\n\nexport function normalizeByColumn(a) {\n  var emptyRow = a[0].map(() => 0);\n  var colDenominators = a\n    .reduce((acc, row) => {\n      row.forEach((cell, j) => {\n        acc[j] += Math.pow(cell, 2);\n      });\n      return acc;\n    }, emptyRow)\n    .map(Math.sqrt);\n  return a.map((row, i) => row.map((v, j) => v / (colDenominators[j] || 1)));\n}\n\nexport function createChromaFilterBank(\n  numFilters,\n  sampleRate,\n  bufferSize,\n  centerOctave = 5,\n  octaveWidth = 2,\n  baseC = true,\n  A440 = 440\n) {\n  var numOutputBins = Math.floor(bufferSize / 2) + 1;\n\n  var frequencyBins = new Array(bufferSize)\n    .fill(0)\n    .map(\n      (_, i) => numFilters * hzToOctaves((sampleRate * i) / bufferSize, A440)\n    );\n\n  // Set a value for the 0 Hz bin that is 1.5 octaves below bin 1\n  // (so chroma is 50% rotated from bin 1, and bin width is broad)\n  frequencyBins[0] = frequencyBins[1] - 1.5 * numFilters;\n\n  var binWidthBins = frequencyBins\n    .slice(1)\n    .map((v, i) => Math.max(v - frequencyBins[i]), 1)\n    .concat([1]);\n\n  var halfNumFilters = Math.round(numFilters / 2);\n\n  var filterPeaks = new Array(numFilters)\n    .fill(0)\n    .map((_, i) =>\n      frequencyBins.map(\n        (frq) =>\n          ((10 * numFilters + halfNumFilters + frq - i) % numFilters) -\n          halfNumFilters\n      )\n    );\n\n  var weights = filterPeaks.map((row, i) =>\n    row.map((_, j) =>\n      Math.exp(-0.5 * Math.pow((2 * filterPeaks[i][j]) / binWidthBins[j], 2))\n    )\n  );\n\n  weights = normalizeByColumn(weights);\n\n  if (octaveWidth) {\n    var octaveWeights = frequencyBins.map((v) =>\n      Math.exp(\n        -0.5 * Math.pow((v / numFilters - centerOctave) / octaveWidth, 2)\n      )\n    );\n    weights = weights.map((row) =>\n      row.map((cell, j) => cell * octaveWeights[j])\n    );\n  }\n\n  if (baseC) {\n    weights = [...weights.slice(3), ...weights.slice(0, 3)];\n  }\n\n  return weights.map((row) => row.slice(0, numOutputBins));\n}\n\nexport function frame(buffer, frameLength, hopLength) {\n  if (buffer.length < frameLength) {\n    throw new Error(\"Buffer is too short for frame length\");\n  }\n  if (hopLength < 1) {\n    throw new Error(\"Hop length cannot be less that 1\");\n  }\n  if (frameLength < 1) {\n    throw new Error(\"Frame length cannot be less that 1\");\n  }\n\n  const numFrames = 1 + Math.floor((buffer.length - frameLength) / hopLength);\n\n  return new Array(numFrames)\n    .fill(0)\n    .map((_, i) => buffer.slice(i * hopLength, i * hopLength + frameLength));\n}\n","export function mu(i: number, amplitudeSpect: Float32Array): number {\n  var numerator = 0;\n  var denominator = 0;\n  for (var k = 0; k < amplitudeSpect.length; k++) {\n    numerator += Math.pow(k, i) * Math.abs(amplitudeSpect[k]);\n    denominator += amplitudeSpect[k];\n  }\n\n  return numerator / denominator;\n}\n","export default function ({\n  ampSpectrum,\n  barkScale,\n}: {\n  ampSpectrum: Float32Array;\n  barkScale: Float32Array;\n}): {\n  specific: Float32Array;\n  total: number;\n} {\n  if (typeof ampSpectrum !== \"object\" || typeof barkScale !== \"object\") {\n    throw new TypeError();\n  }\n\n  var NUM_BARK_BANDS = 24;\n  var specific = new Float32Array(NUM_BARK_BANDS);\n  var total = 0;\n  var normalisedSpectrum = ampSpectrum;\n  var bbLimits = new Int32Array(NUM_BARK_BANDS + 1);\n\n  bbLimits[0] = 0;\n  var currentBandEnd =\n    barkScale[normalisedSpectrum.length - 1] / NUM_BARK_BANDS;\n  var currentBand = 1;\n  for (let i = 0; i < normalisedSpectrum.length; i++) {\n    while (barkScale[i] > currentBandEnd) {\n      bbLimits[currentBand++] = i;\n      currentBandEnd =\n        (currentBand * barkScale[normalisedSpectrum.length - 1]) /\n        NUM_BARK_BANDS;\n    }\n  }\n\n  bbLimits[NUM_BARK_BANDS] = normalisedSpectrum.length - 1;\n\n  //process\n\n  for (let i = 0; i < NUM_BARK_BANDS; i++) {\n    let sum = 0;\n    for (let j = bbLimits[i]; j < bbLimits[i + 1]; j++) {\n      sum += normalisedSpectrum[j];\n    }\n\n    specific[i] = Math.pow(sum, 0.23);\n  }\n\n  //get total loudness\n  for (let i = 0; i < specific.length; i++) {\n    total += specific[i];\n  }\n\n  return {\n    specific: specific,\n    total: total,\n  };\n}\n","export default function ({\n  ampSpectrum,\n}: {\n  ampSpectrum: Float32Array;\n}): Float32Array {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError();\n  }\n\n  var powerSpectrum = new Float32Array(ampSpectrum.length);\n  for (var i = 0; i < powerSpectrum.length; i++) {\n    powerSpectrum[i] = Math.pow(ampSpectrum[i], 2);\n  }\n\n  return powerSpectrum;\n}\n","/*===========================================================================*\\\n * Discrete Cosine Transform\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Mel-scale and its related coefficients used in\n * human speech analysis.\n\\*===========================================================================*/\nvar cosMap = null;\n\n// Builds a cosine map for the given input size. This allows multiple input sizes to be memoized automagically\n// if you want to run the DCT over and over.\nvar memoizeCosines = function(N) {\n  cosMap = cosMap || {};\n  cosMap[N] = new Array(N*N);\n\n  var PI_N = Math.PI / N;\n\n  for (var k = 0; k < N; k++) {\n    for (var n = 0; n < N; n++) {\n      cosMap[N][n + (k * N)] = Math.cos(PI_N * (n + 0.5) * k);\n    }\n  }\n};\n\nfunction dct(signal, scale) {\n  var L = signal.length;\n  scale = scale || 2;\n\n  if (!cosMap || !cosMap[L]) memoizeCosines(L);\n\n  var coefficients = signal.map(function () {return 0;});\n\n  return coefficients.map(function (__, ix) {\n    return scale * signal.reduce(function (prev, cur, ix_, arr) {\n      return prev + (cur * cosMap[L][ix_ + (ix * L)]);\n    }, 0);\n  });\n};\n\nmodule.exports = dct;\n","module.exports = require('./src/dct.js');\n","import rms from \"./extractors/rms\";\nimport energy from \"./extractors/energy\";\nimport spectralSlope from \"./extractors/spectralSlope\";\nimport spectralCentroid from \"./extractors/spectralCentroid\";\nimport spectralRolloff from \"./extractors/spectralRolloff\";\nimport spectralFlatness from \"./extractors/spectralFlatness\";\nimport spectralSpread from \"./extractors/spectralSpread\";\nimport spectralSkewness from \"./extractors/spectralSkewness\";\nimport spectralKurtosis from \"./extractors/spectralKurtosis\";\nimport zcr from \"./extractors/zcr\";\nimport loudness from \"./extractors/loudness\";\nimport perceptualSpread from \"./extractors/perceptualSpread\";\nimport perceptualSharpness from \"./extractors/perceptualSharpness\";\nimport mfcc from \"./extractors/mfcc\";\nimport chroma from \"./extractors/chroma\";\nimport powerSpectrum from \"./extractors/powerSpectrum\";\nimport spectralFlux from \"./extractors/spectralFlux\";\n\nlet buffer = function (args) {\n  return args.signal;\n};\n\nlet complexSpectrum = function (args) {\n  return args.complexSpectrum;\n};\n\nlet amplitudeSpectrum = function (args) {\n  return args.ampSpectrum;\n};\n\nexport {\n  buffer,\n  rms,\n  energy,\n  complexSpectrum,\n  spectralSlope,\n  spectralCentroid,\n  spectralRolloff,\n  spectralFlatness,\n  spectralSpread,\n  spectralSkewness,\n  spectralKurtosis,\n  amplitudeSpectrum,\n  zcr,\n  loudness,\n  perceptualSpread,\n  perceptualSharpness,\n  powerSpectrum,\n  mfcc,\n  chroma,\n  spectralFlux,\n};\n","export default function ({ signal }: { signal: Float32Array }): number {\n  // Keeping this bad runtime typecheck for consistency\n  if (typeof signal !== \"object\") {\n    throw new TypeError();\n  }\n\n  var rms = 0;\n  for (var i = 0; i < signal.length; i++) {\n    rms += Math.pow(signal[i], 2);\n  }\n\n  rms = rms / signal.length;\n  rms = Math.sqrt(rms);\n\n  return rms;\n}\n","export default function ({ signal }: { signal: Float32Array }): number {\n  if (typeof signal !== \"object\") {\n    throw new TypeError();\n  }\n\n  var energy = 0;\n  for (var i = 0; i < signal.length; i++) {\n    energy += Math.pow(Math.abs(signal[i]), 2);\n  }\n\n  return energy;\n}\n","export default function ({\n  ampSpectrum,\n  sampleRate,\n  bufferSize,\n}: {\n  ampSpectrum: Float32Array;\n  sampleRate: number;\n  bufferSize: number;\n}): number {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError();\n  }\n\n  //linear regression\n  let ampSum = 0;\n  let freqSum = 0;\n  let freqs = new Float32Array(ampSpectrum.length);\n  let powFreqSum = 0;\n  let ampFreqSum = 0;\n\n  for (var i = 0; i < ampSpectrum.length; i++) {\n    ampSum += ampSpectrum[i];\n    let curFreq = (i * sampleRate) / bufferSize;\n    freqs[i] = curFreq;\n    powFreqSum += curFreq * curFreq;\n    freqSum += curFreq;\n    ampFreqSum += curFreq * ampSpectrum[i];\n  }\n\n  return (\n    (ampSpectrum.length * ampFreqSum - freqSum * ampSum) /\n    (ampSum * (powFreqSum - Math.pow(freqSum, 2)))\n  );\n}\n","import { mu } from \"./extractorUtilities\";\n\nexport default function ({\n  ampSpectrum,\n}: {\n  ampSpectrum: Float32Array;\n}): number {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError();\n  }\n\n  return mu(1, ampSpectrum);\n}\n","export default function ({\n  ampSpectrum,\n  sampleRate,\n}: {\n  ampSpectrum: Float32Array;\n  sampleRate: number;\n}): number {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError();\n  }\n\n  var ampspec = ampSpectrum;\n\n  //calculate nyquist bin\n  var nyqBin = sampleRate / (2 * (ampspec.length - 1));\n  var ec = 0;\n  for (var i = 0; i < ampspec.length; i++) {\n    ec += ampspec[i];\n  }\n\n  var threshold = 0.99 * ec;\n  var n = ampspec.length - 1;\n  while (ec > threshold && n >= 0) {\n    ec -= ampspec[n];\n    --n;\n  }\n\n  return (n + 1) * nyqBin;\n}\n","export default function ({\n  ampSpectrum,\n}: {\n  ampSpectrum: Float32Array;\n}): number {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError();\n  }\n\n  var numerator = 0;\n  var denominator = 0;\n  for (var i = 0; i < ampSpectrum.length; i++) {\n    numerator += Math.log(ampSpectrum[i]);\n    denominator += ampSpectrum[i];\n  }\n\n  return (\n    (Math.exp(numerator / ampSpectrum.length) * ampSpectrum.length) /\n    denominator\n  );\n}\n","import { mu } from \"./extractorUtilities\";\n\nexport default function ({\n  ampSpectrum,\n}: {\n  ampSpectrum: Float32Array;\n}): number {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError();\n  }\n\n  return Math.sqrt(mu(2, ampSpectrum) - Math.pow(mu(1, ampSpectrum), 2));\n}\n","import { mu } from \"./extractorUtilities\";\n\nexport default function ({\n  ampSpectrum,\n}: {\n  ampSpectrum: Float32Array;\n}): number {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError();\n  }\n\n  var mu1 = mu(1, ampSpectrum);\n  var mu2 = mu(2, ampSpectrum);\n  var mu3 = mu(3, ampSpectrum);\n  var numerator = 2 * Math.pow(mu1, 3) - 3 * mu1 * mu2 + mu3;\n  var denominator = Math.pow(Math.sqrt(mu2 - Math.pow(mu1, 2)), 3);\n  return numerator / denominator;\n}\n","import { mu } from \"./extractorUtilities\";\n\nexport default function ({\n  ampSpectrum,\n}: {\n  ampSpectrum: Float32Array;\n}): number {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError();\n  }\n\n  var ampspec = ampSpectrum;\n  var mu1 = mu(1, ampspec);\n  var mu2 = mu(2, ampspec);\n  var mu3 = mu(3, ampspec);\n  var mu4 = mu(4, ampspec);\n  var numerator = -3 * Math.pow(mu1, 4) + 6 * mu1 * mu2 - 4 * mu1 * mu3 + mu4;\n  var denominator = Math.pow(Math.sqrt(mu2 - Math.pow(mu1, 2)), 4);\n  return numerator / denominator;\n}\n","export default function ({ signal }: { signal: Float32Array }): number {\n  if (typeof signal !== \"object\") {\n    throw new TypeError();\n  }\n\n  var zcr = 0;\n  for (var i = 1; i < signal.length; i++) {\n    if (\n      (signal[i - 1] >= 0 && signal[i] < 0) ||\n      (signal[i - 1] < 0 && signal[i] >= 0)\n    ) {\n      zcr++;\n    }\n  }\n\n  return zcr;\n}\n","import loudness from \"./loudness\";\n\nexport default function ({\n  ampSpectrum,\n  barkScale,\n}: {\n  ampSpectrum: Float32Array;\n  barkScale: Float32Array;\n}): number {\n  var loudnessValue = loudness({ ampSpectrum, barkScale });\n\n  var max = 0;\n  for (var i = 0; i < loudnessValue.specific.length; i++) {\n    if (loudnessValue.specific[i] > max) {\n      max = loudnessValue.specific[i];\n    }\n  }\n\n  var spread = Math.pow((loudnessValue.total - max) / loudnessValue.total, 2);\n\n  return spread;\n}\n","import loudness from \"./loudness\";\n\nexport default function ({\n  ampSpectrum,\n  barkScale,\n}: {\n  ampSpectrum: Float32Array;\n  barkScale: Float32Array;\n}): number {\n  var loudnessValue = loudness({ ampSpectrum, barkScale });\n  var spec = loudnessValue.specific;\n  var output = 0;\n\n  for (var i = 0; i < spec.length; i++) {\n    if (i < 15) {\n      output += (i + 1) * spec[i + 1];\n    } else {\n      output += 0.066 * Math.exp(0.171 * (i + 1));\n    }\n  }\n\n  output *= 0.11 / loudnessValue.total;\n\n  return output;\n}\n","import extractPowerSpectrum from \"./powerSpectrum\";\nimport dct from \"dct\";\n\nexport default function ({\n  ampSpectrum,\n  melFilterBank,\n  numberOfMFCCCoefficients,\n  bufferSize,\n}: {\n  ampSpectrum: Float32Array;\n  melFilterBank: number[][];\n  numberOfMFCCCoefficients: number;\n  bufferSize: number;\n}): number[] {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError(\"Valid ampSpectrum is required to generate MFCC\");\n  }\n  if (typeof melFilterBank !== \"object\") {\n    throw new TypeError(\"Valid melFilterBank is required to generate MFCC\");\n  }\n\n  let _numberOfMFCCCoefficients = Math.min(\n    40,\n    Math.max(1, numberOfMFCCCoefficients || 13)\n  );\n\n  // Tutorial from:\n  // http://practicalcryptography.com/miscellaneous/machine-learning\n  // /guide-mel-frequency-cepstral-coefficients-mfccs/\n  // @ts-ignore\n  let powSpec = extractPowerSpectrum({ ampSpectrum });\n  let numFilters = melFilterBank.length;\n  let filtered: Float32Array[] = Array(numFilters);\n\n  if (numFilters < _numberOfMFCCCoefficients) {\n    throw new Error(\n      \"Insufficient filter bank for requested number of coefficients\"\n    );\n  }\n\n  let loggedMelBands: Float32Array = new Float32Array(numFilters);\n\n  for (let i = 0; i < loggedMelBands.length; i++) {\n    filtered[i] = new Float32Array(bufferSize / 2);\n    loggedMelBands[i] = 0;\n    for (let j = 0; j < bufferSize / 2; j++) {\n      //point-wise multiplication between power spectrum and filterbanks.\n      filtered[i][j] = melFilterBank[i][j] * powSpec[j];\n\n      //summing up all of the coefficients into one array\n      loggedMelBands[i] += filtered[i][j];\n    }\n\n    //log each coefficient.\n    loggedMelBands[i] = Math.log(loggedMelBands[i] + 1);\n  }\n\n  //dct\n  let loggedMelBandsArray: number[] =\n    Array.prototype.slice.call(loggedMelBands);\n  let mfccs: number[] = dct(loggedMelBandsArray).slice(\n    0,\n    _numberOfMFCCCoefficients\n  );\n\n  return mfccs;\n}\n","export default function ({\n  ampSpectrum,\n  chromaFilterBank,\n}: {\n  ampSpectrum: Float32Array;\n  chromaFilterBank: number[][];\n}): number[] {\n  if (typeof ampSpectrum !== \"object\") {\n    throw new TypeError(\"Valid ampSpectrum is required to generate chroma\");\n  }\n  if (typeof chromaFilterBank !== \"object\") {\n    throw new TypeError(\n      \"Valid chromaFilterBank is required to generate chroma\"\n    );\n  }\n\n  var chromagram = chromaFilterBank.map((row, i) =>\n    ampSpectrum.reduce((acc, v, j) => acc + v * row[j], 0)\n  );\n  var maxVal = Math.max(...chromagram);\n\n  return maxVal ? chromagram.map((v) => v / maxVal) : chromagram;\n}\n","// This file isn't being typechecked at all because there are major issues with it.\n// See #852 for details. Once that's merged, this file should be typechecked.\n// @ts-nocheck\nexport default function ({\n  signal,\n  previousSignal,\n  bufferSize,\n}: {\n  signal: Float32Array;\n  previousSignal: Float32Array;\n  bufferSize: number;\n}): number {\n  if (typeof signal !== \"object\" || typeof previousSignal != \"object\") {\n    throw new TypeError();\n  }\n\n  let sf = 0;\n  for (let i = -(bufferSize / 2); i < signal.length / 2 - 1; i++) {\n    x = Math.abs(signal[i]) - Math.abs(previousSignal[i]);\n    sf += (x + Math.abs(x)) / 2;\n  }\n\n  return sf;\n}\n","'use strict';\n\n// memoization of the reversal of different lengths.\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar memoizedReversal = {};\nvar memoizedZeroBuffers = {};\n\nvar constructComplexArray = function constructComplexArray(signal) {\n  var complexSignal = {};\n\n  complexSignal.real = signal.real === undefined ? signal.slice() : signal.real.slice();\n\n  var bufferSize = complexSignal.real.length;\n\n  if (memoizedZeroBuffers[bufferSize] === undefined) {\n    memoizedZeroBuffers[bufferSize] = Array.apply(null, Array(bufferSize)).map(Number.prototype.valueOf, 0);\n  }\n\n  complexSignal.imag = memoizedZeroBuffers[bufferSize].slice();\n\n  return complexSignal;\n};\n\nvar bitReverseArray = function bitReverseArray(N) {\n  if (memoizedReversal[N] === undefined) {\n    var maxBinaryLength = (N - 1).toString(2).length; //get the binary length of the largest index.\n    var templateBinary = '0'.repeat(maxBinaryLength); //create a template binary of that length.\n    var reversed = {};\n    for (var n = 0; n < N; n++) {\n      var currBinary = n.toString(2); //get binary value of current index.\n\n      //prepend zeros from template to current binary. This makes binary values of all indices have the same length.\n      currBinary = templateBinary.substr(currBinary.length) + currBinary;\n\n      currBinary = [].concat(_toConsumableArray(currBinary)).reverse().join(''); //reverse\n      reversed[n] = parseInt(currBinary, 2); //convert to decimal\n    }\n    memoizedReversal[N] = reversed; //save\n  }\n  return memoizedReversal[N];\n};\n\n// complex multiplication\nvar multiply = function multiply(a, b) {\n  return {\n    'real': a.real * b.real - a.imag * b.imag,\n    'imag': a.real * b.imag + a.imag * b.real\n  };\n};\n\n// complex addition\nvar add = function add(a, b) {\n  return {\n    'real': a.real + b.real,\n    'imag': a.imag + b.imag\n  };\n};\n\n// complex subtraction\nvar subtract = function subtract(a, b) {\n  return {\n    'real': a.real - b.real,\n    'imag': a.imag - b.imag\n  };\n};\n\n// euler's identity e^x = cos(x) + sin(x)\nvar euler = function euler(kn, N) {\n  var x = -2 * Math.PI * kn / N;\n  return { 'real': Math.cos(x), 'imag': Math.sin(x) };\n};\n\n// complex conjugate\nvar conj = function conj(a) {\n  a.imag *= -1;\n  return a;\n};\n\nmodule.exports = {\n  bitReverseArray: bitReverseArray,\n  multiply: multiply,\n  add: add,\n  subtract: subtract,\n  euler: euler,\n  conj: conj,\n  constructComplexArray: constructComplexArray\n};","'use strict';\n\nvar utils = require('./utils');\n\n// real to complex fft\nvar fft = function fft(signal) {\n\n  var complexSignal = {};\n\n  if (signal.real === undefined || signal.imag === undefined) {\n    complexSignal = utils.constructComplexArray(signal);\n  } else {\n    complexSignal.real = signal.real.slice();\n    complexSignal.imag = signal.imag.slice();\n  }\n\n  var N = complexSignal.real.length;\n  var logN = Math.log2(N);\n\n  if (Math.round(logN) != logN) throw new Error('Input size must be a power of 2.');\n\n  if (complexSignal.real.length != complexSignal.imag.length) {\n    throw new Error('Real and imaginary components must have the same length.');\n  }\n\n  var bitReversedIndices = utils.bitReverseArray(N);\n\n  // sort array\n  var ordered = {\n    'real': [],\n    'imag': []\n  };\n\n  for (var i = 0; i < N; i++) {\n    ordered.real[bitReversedIndices[i]] = complexSignal.real[i];\n    ordered.imag[bitReversedIndices[i]] = complexSignal.imag[i];\n  }\n\n  for (var _i = 0; _i < N; _i++) {\n    complexSignal.real[_i] = ordered.real[_i];\n    complexSignal.imag[_i] = ordered.imag[_i];\n  }\n  // iterate over the number of stages\n  for (var n = 1; n <= logN; n++) {\n    var currN = Math.pow(2, n);\n\n    // find twiddle factors\n    for (var k = 0; k < currN / 2; k++) {\n      var twiddle = utils.euler(k, currN);\n\n      // on each block of FT, implement the butterfly diagram\n      for (var m = 0; m < N / currN; m++) {\n        var currEvenIndex = currN * m + k;\n        var currOddIndex = currN * m + k + currN / 2;\n\n        var currEvenIndexSample = {\n          'real': complexSignal.real[currEvenIndex],\n          'imag': complexSignal.imag[currEvenIndex]\n        };\n        var currOddIndexSample = {\n          'real': complexSignal.real[currOddIndex],\n          'imag': complexSignal.imag[currOddIndex]\n        };\n\n        var odd = utils.multiply(twiddle, currOddIndexSample);\n\n        var subtractionResult = utils.subtract(currEvenIndexSample, odd);\n        complexSignal.real[currOddIndex] = subtractionResult.real;\n        complexSignal.imag[currOddIndex] = subtractionResult.imag;\n\n        var additionResult = utils.add(odd, currEvenIndexSample);\n        complexSignal.real[currEvenIndex] = additionResult.real;\n        complexSignal.imag[currEvenIndex] = additionResult.imag;\n      }\n    }\n  }\n\n  return complexSignal;\n};\n\n// complex to real ifft\nvar ifft = function ifft(signal) {\n\n  if (signal.real === undefined || signal.imag === undefined) {\n    throw new Error(\"IFFT only accepts a complex input.\");\n  }\n\n  var N = signal.real.length;\n\n  var complexSignal = {\n    'real': [],\n    'imag': []\n  };\n\n  //take complex conjugate in order to be able to use the regular FFT for IFFT\n  for (var i = 0; i < N; i++) {\n    var currentSample = {\n      'real': signal.real[i],\n      'imag': signal.imag[i]\n    };\n\n    var conjugateSample = utils.conj(currentSample);\n    complexSignal.real[i] = conjugateSample.real;\n    complexSignal.imag[i] = conjugateSample.imag;\n  }\n\n  //compute\n  var X = fft(complexSignal);\n\n  //normalize\n  complexSignal.real = X.real.map(function (val) {\n    return val / N;\n  });\n\n  complexSignal.imag = X.imag.map(function (val) {\n    return val / N;\n  });\n\n  return complexSignal;\n};\n\nmodule.exports = {\n  fft: fft,\n  ifft: ifft\n};","import * as utilities from \"./utilities\";\nimport * as featureExtractors from \"./featureExtractors\";\n\n/**\n * MeydaAnalyzer\n * @classdesc\n * Meyda's interface to the Web Audio API. MeydaAnalyzer abstracts an API on\n * top of the Web Audio API's ScriptProcessorNode, running the Meyda audio\n * feature extractors inside that context.\n *\n * MeydaAnalyzer's constructor should not be called directly - MeydaAnalyzer\n * objects should be generated using the {@link Meyda.createMeydaAnalyzer}\n * factory function in the main Meyda class.\n *\n * @example\n * const analyzer = Meyda.createMeydaAnalyzer({\n *   \"audioContext\": audioContext,\n *   \"source\": source,\n *   \"bufferSize\": 512,\n *   \"featureExtractors\": [\"rms\"],\n *   \"inputs\": 2,\n *   \"numberOfMFCCCoefficients\": 20\n *   \"callback\": features => {\n *     levelRangeElement.value = features.rms;\n *   }\n * });\n * @hideconstructor\n */\nexport class MeydaAnalyzer {\n  _m: any;\n  constructor(options, _this) {\n    this._m = _this;\n    if (!options.audioContext) {\n      throw this._m.errors.noAC;\n    } else if (\n      options.bufferSize &&\n      !utilities.isPowerOfTwo(options.bufferSize)\n    ) {\n      throw this._m._errors.notPow2;\n    } else if (!options.source) {\n      throw this._m._errors.noSource;\n    }\n\n    this._m.audioContext = options.audioContext;\n\n    // TODO: validate options\n    this._m.bufferSize = options.bufferSize || this._m.bufferSize || 256;\n    this._m.hopSize = options.hopSize || this._m.hopSize || this._m.bufferSize;\n    this._m.sampleRate =\n      options.sampleRate || this._m.audioContext.sampleRate || 44100;\n    this._m.callback = options.callback;\n    this._m.windowingFunction = options.windowingFunction || \"hanning\";\n    this._m.featureExtractors = featureExtractors;\n    this._m.EXTRACTION_STARTED = options.startImmediately || false;\n    this._m.channel = typeof options.channel === \"number\" ? options.channel : 0;\n    this._m.inputs = options.inputs || 1;\n    this._m.outputs = options.outputs || 1;\n    this._m.numberOfMFCCCoefficients =\n      options.numberOfMFCCCoefficients ||\n      this._m.numberOfMFCCCoefficients ||\n      13;\n\n    //create nodes\n    this._m.spn = this._m.audioContext.createScriptProcessor(\n      this._m.bufferSize,\n      this._m.inputs,\n      this._m.outputs\n    );\n    this._m.spn.connect(this._m.audioContext.destination);\n\n    this._m._featuresToExtract = options.featureExtractors || [];\n\n    //always recalculate BS and MFB when a new Meyda analyzer is created.\n    this._m.barkScale = utilities.createBarkScale(\n      this._m.bufferSize,\n      this._m.sampleRate,\n      this._m.bufferSize\n    );\n    this._m.melFilterBank = utilities.createMelFilterBank(\n      Math.max(this._m.melBands, this._m.numberOfMFCCCoefficients),\n      this._m.sampleRate,\n      this._m.bufferSize\n    );\n\n    this._m.inputData = null;\n    this._m.previousInputData = null;\n\n    this._m.frame = null;\n    this._m.previousFrame = null;\n\n    this.setSource(options.source);\n\n    this._m.spn.onaudioprocess = (e) => {\n      var buffer;\n      if (this._m.inputData !== null) {\n        this._m.previousInputData = this._m.inputData;\n      }\n\n      this._m.inputData = e.inputBuffer.getChannelData(this._m.channel);\n\n      if (!this._m.previousInputData) {\n        buffer = this._m.inputData;\n      } else {\n        buffer = new Float32Array(\n          this._m.previousInputData.length +\n            this._m.inputData.length -\n            this._m.hopSize\n        );\n        buffer.set(this._m.previousInputData.slice(this._m.hopSize));\n        buffer.set(\n          this._m.inputData,\n          this._m.previousInputData.length - this._m.hopSize\n        );\n      }\n\n      var frames = utilities.frame(buffer, this._m.bufferSize, this._m.hopSize);\n\n      frames.forEach((f) => {\n        this._m.frame = f;\n\n        var features = this._m.extract(\n          this._m._featuresToExtract,\n          this._m.frame,\n          this._m.previousFrame\n        );\n\n        // call callback if applicable\n        if (\n          typeof this._m.callback === \"function\" &&\n          this._m.EXTRACTION_STARTED\n        ) {\n          this._m.callback(features);\n        }\n\n        this._m.previousFrame = this._m.frame;\n      });\n    };\n  }\n\n  /**\n   * Start feature extraction\n   * The audio features will be passed to the callback function that was defined\n   * in the MeydaOptions that were passed to the factory when constructing the\n   * MeydaAnalyzer.\n   * @param {(string|Array.<string>)} [features]\n   * Change the features that Meyda is extracting. Defaults to the features that\n   * were set upon construction in the options parameter.\n   * @example\n   * analyzer.start('chroma');\n   */\n  start(features) {\n    this._m._featuresToExtract = features || this._m._featuresToExtract;\n    this._m.EXTRACTION_STARTED = true;\n  }\n\n  /**\n   * Stop feature extraction.\n   * @example\n   * analyzer.stop();\n   */\n  stop() {\n    this._m.EXTRACTION_STARTED = false;\n  }\n\n  /**\n   * Set the Audio Node for Meyda to listen to.\n   * @param {AudioNode} source - The Audio Node for Meyda to listen to\n   * @example\n   * analyzer.setSource(audioSourceNode);\n   */\n  setSource(source) {\n    this._m.source && this._m.source.disconnect(this._m.spn);\n    this._m.source = source;\n    this._m.source.connect(this._m.spn);\n  }\n\n  /**\n   * Set the channel of the audio node for Meyda to listen to\n   * @param {number} channel - the index of the channel on the input audio node\n   * for Meyda to listen to.\n   * @example\n   * analyzer.setChannel(0);\n   */\n  setChannel(channel) {\n    if (channel <= this._m.inputs) {\n      this._m.channel = channel;\n    } else {\n      console.error(\n        `Channel ${channel} does not exist. Make sure you've provided a value for 'inputs' that is greater than ${channel} when instantiating the MeydaAnalyzer`\n      );\n    }\n  }\n\n  /**\n   * Get a set of features from the current frame.\n   * @param {(string|Array.<string>)} [features]\n   * Change the features that Meyda is extracting\n   * @example\n   * analyzer.get('spectralFlatness');\n   */\n  get(features) {\n    if (this._m.inputData) {\n      return this._m.extract(\n        features || this._m._featuresToExtract,\n        this._m.inputData,\n        this._m.previousInputData\n      );\n    } else {\n      return null;\n    }\n  }\n}\n","import * as utilities from \"./utilities\";\nimport * as extractors from \"./featureExtractors\";\nimport { fft } from \"fftjs\";\nimport { MeydaAnalyzer } from \"./meyda-wa\";\n\n/**\n * Meyda Module\n * @module meyda\n */\n\n/**\n * Options for constructing a MeydaAnalyzer\n * @typedef {Object} MeydaOptions\n * @property {AudioContext} audioContext - The Audio Context for the MeydaAnalyzer to operate in.\n * @property {AudioNode} source - The Audio Node for Meyda to listen to.\n * @property {number} [bufferSize] - The size of the buffer.\n * @property {number} [hopSize] - The hop size between buffers.\n * @property {number} [sampleRate] - The number of samples per second in the audio context.\n * @property {Function} [callback] - A function to receive the frames of audio features\n * @property {string} [windowingFunction] - The Windowing Function to apply to the signal before transformation to the frequency domain\n * @property {string|Array.<string>} [featureExtractors] - Specify the feature extractors you want to run on the audio.\n * @property {boolean} [startImmediately] - Pass `true` to start feature extraction immediately\n * @property {number} [numberOfMFCCCoefficients] - The number of MFCC co-efficients that the MFCC feature extractor should return\n */\n\n/**\n * Web Audio context\n * Either an {@link AudioContext|https://developer.mozilla.org/en-US/docs/Web/API/AudioContext}\n * or an {@link OfflineAudioContext|https://developer.mozilla.org/en-US/docs/Web/API/OfflineAudioContext}\n * @typedef {Object} AudioContext\n */\n\n/**\n * AudioNode\n * A Web AudioNode\n * @typedef {Object} AudioNode\n */\n\n/**\n * ScriptProcessorNode\n * A Web Audio ScriptProcessorNode\n * @typedef {Object} ScriptProcessorNode\n */\n\n/**\n * @class Meyda\n * @hideconstructor\n * @classdesc\n * The schema for the default export of the Meyda library.\n * @example\n * var Meyda = require('meyda');\n */\nvar Meyda = {\n  /**\n   * Meyda stores a reference to the relevant audio context here for use inside\n   * the Web Audio API.\n   * @instance\n   * @member {AudioContext}\n   */\n  audioContext: null,\n  /**\n   * Meyda keeps an internal ScriptProcessorNode in which it runs audio feature\n   * extraction. The ScriptProcessorNode is stored in this member variable.\n   * @instance\n   * @member {ScriptProcessorNode}\n   */\n  spn: null,\n  /**\n   * The length of each buffer that Meyda will extract audio on. When recieving\n   * input via the Web Audio API, the Script Processor Node chunks incoming audio\n   * into arrays of this length. Longer buffers allow for more precision in the\n   * frequency domain, but increase the amount of time it takes for Meyda to\n   * output a set of audio features for the buffer. You can calculate how many\n   * sets of audio features Meyda will output per second by dividing the\n   * buffer size by the sample rate. If you're using Meyda for visualisation,\n   * make sure that you're collecting audio features at a rate that's faster\n   * than or equal to the video frame rate you expect.\n   * @instance\n   * @member {number}\n   */\n  bufferSize: 512,\n  /**\n   * The number of samples per second of the incoming audio. This affects\n   * feature extraction outside of the context of the Web Audio API, and must be\n   * set accurately - otherwise calculations will be off.\n   * @instance\n   * @member {number}\n   */\n  sampleRate: 44100,\n  /**\n   * The number of Mel bands to use in the Mel Frequency Cepstral Co-efficients\n   * feature extractor\n   * @instance\n   * @member {number}\n   */\n  melBands: 26,\n  /**\n   * The number of bands to divide the spectrum into for the Chroma feature\n   * extractor. 12 is the standard number of semitones per octave in the western\n   * music tradition, but Meyda can use an arbitrary number of bands, which\n   * can be useful for microtonal music.\n   * @instance\n   * @member {number}\n   */\n  chromaBands: 12,\n  /**\n   * A function you can provide that will be called for each buffer that Meyda\n   * receives from its source node\n   * @instance\n   * @member {Function}\n   */\n  callback: null,\n  /**\n   * Specify the windowing function to apply to the buffer before the\n   * transformation from the time domain to the frequency domain is performed\n   *\n   * The default windowing function is the hanning window.\n   *\n   * @instance\n   * @member {string}\n   */\n  windowingFunction: \"hanning\",\n  /**\n   * @member {object}\n   */\n  featureExtractors: extractors,\n  EXTRACTION_STARTED: false,\n  /**\n   * The number of MFCC co-efficients that the MFCC feature extractor should return\n   * @instance\n   * @member {number}\n   */\n  numberOfMFCCCoefficients: 13,\n  _featuresToExtract: [],\n  windowing: utilities.applyWindow,\n  _errors: {\n    notPow2: new Error(\n      \"Meyda: Buffer size must be a power of 2, e.g. 64 or 512\"\n    ),\n    featureUndef: new Error(\"Meyda: No features defined.\"),\n    invalidFeatureFmt: new Error(\"Meyda: Invalid feature format\"),\n    invalidInput: new Error(\"Meyda: Invalid input.\"),\n    noAC: new Error(\"Meyda: No AudioContext specified.\"),\n    noSource: new Error(\"Meyda: No source node specified.\"),\n  },\n\n  /**\n   * @summary\n   * Create a MeydaAnalyzer\n   *\n   * A factory function for creating a MeydaAnalyzer, the interface for using\n   * Meyda in the context of Web Audio.\n   *\n   * @method\n   * @param {MeydaOptions} options Options - an object containing configuration\n   * @returns {MeydaAnalyzer}\n   * @example\n   * const analyzer = Meyda.createMeydaAnalyzer({\n   *   \"audioContext\": audioContext,\n   *   \"source\": source,\n   *   \"bufferSize\": 512,\n   *   \"featureExtractors\": [\"rms\"],\n   *   \"inputs\": 2,\n   *   \"callback\": features => {\n   *     levelRangeElement.value = features.rms;\n   *   }\n   * });\n   */\n  createMeydaAnalyzer: function (options) {\n    return new MeydaAnalyzer(options, Object.assign({}, Meyda));\n  },\n\n  /**\n   * List available audio feature extractors. Return format provides the key to\n   * be used in selecting the extractor in the extract methods\n   *\n   * @returns {Array.<string>} featureExtractors - a list of the keys of\n   * available audio feature extractors\n   */\n\n  listAvailableFeatureExtractors: function () {\n    return Object.keys(this.featureExtractors);\n  },\n\n  /**\n   * Extract an audio feature from a buffer\n   *\n   * Unless `meyda.windowingFunction` is set otherwise, `extract` will\n   * internally apply a hanning window to the buffer prior to conversion into\n   * the frequency domain.\n   *\n   * @function\n   * @param {(string|Array.<string>)} feature - the feature you want to extract\n   * @param {Array.<number>} signal\n   * An array of numbers that represents the signal. It should be of length\n   * `meyda.bufferSize`\n   * @param {Array.<number>} [previousSignal] - the previous buffer\n   * @returns {object} Features\n   * @example\n   * meyda.bufferSize = 2048;\n   * const features = meyda.extract(['zcr', 'spectralCentroid'], signal);\n   */\n  extract: function (feature, signal, previousSignal) {\n    if (!signal) throw this._errors.invalidInput;\n    else if (typeof signal != \"object\") throw this._errors.invalidInput;\n    else if (!feature) throw this._errors.featureUndef;\n    else if (!utilities.isPowerOfTwo(signal.length)) throw this._errors.notPow2;\n\n    if (\n      typeof this.barkScale == \"undefined\" ||\n      this.barkScale.length != this.bufferSize\n    ) {\n      this.barkScale = utilities.createBarkScale(\n        this.bufferSize,\n        this.sampleRate,\n        this.bufferSize\n      );\n    }\n\n    // Recalculate mel bank if buffer length changed\n    if (\n      typeof this.melFilterBank == \"undefined\" ||\n      this.barkScale.length != this.bufferSize ||\n      this.melFilterBank.length != this.melBands\n    ) {\n      this.melFilterBank = utilities.createMelFilterBank(\n        Math.max(this.melBands, this.numberOfMFCCCoefficients),\n        this.sampleRate,\n        this.bufferSize\n      );\n    }\n\n    // Recalculate chroma bank if buffer length changed\n    if (\n      typeof this.chromaFilterBank == \"undefined\" ||\n      this.chromaFilterBank.length != this.chromaBands\n    ) {\n      this.chromaFilterBank = utilities.createChromaFilterBank(\n        this.chromaBands,\n        this.sampleRate,\n        this.bufferSize\n      );\n    }\n\n    if (typeof signal.buffer == \"undefined\") {\n      //signal is a normal array, convert to F32A\n      this.signal = utilities.arrayToTyped(signal);\n    } else {\n      this.signal = signal;\n    }\n\n    let preparedSignal = prepareSignalWithSpectrum(\n      signal,\n      this.windowingFunction,\n      this.bufferSize\n    );\n\n    this.signal = preparedSignal.windowedSignal;\n    this.complexSpectrum = preparedSignal.complexSpectrum;\n    this.ampSpectrum = preparedSignal.ampSpectrum;\n\n    if (previousSignal) {\n      let preparedSignal = prepareSignalWithSpectrum(\n        previousSignal,\n        this.windowingFunction,\n        this.bufferSize\n      );\n\n      this.previousSignal = preparedSignal.windowedSignal;\n      this.previousComplexSpectrum = preparedSignal.complexSpectrum;\n      this.previousAmpSpectrum = preparedSignal.ampSpectrum;\n    }\n\n    const extract = (feature) => {\n      return this.featureExtractors[feature]({\n        ampSpectrum: this.ampSpectrum,\n        chromaFilterBank: this.chromaFilterBank,\n        complexSpectrum: this.complexSpectrum,\n        signal: this.signal,\n        bufferSize: this.bufferSize,\n        sampleRate: this.sampleRate,\n        barkScale: this.barkScale,\n        melFilterBank: this.melFilterBank,\n        previousSignal: this.previousSignal,\n        previousAmpSpectrum: this.previousAmpSpectrum,\n        previousComplexSpectrum: this.previousComplexSpectrum,\n        numberOfMFCCCoefficients: this.numberOfMFCCCoefficients,\n      });\n    };\n\n    if (typeof feature === \"object\") {\n      return feature.reduce(\n        (acc, el) =>\n          Object.assign({}, acc, {\n            [el]: extract(el),\n          }),\n        {}\n      );\n    } else if (typeof feature === \"string\") {\n      return extract(feature);\n    } else {\n      throw this._errors.invalidFeatureFmt;\n    }\n  },\n};\n\nvar prepareSignalWithSpectrum = function (\n  signal,\n  windowingFunction,\n  bufferSize\n) {\n  var preparedSignal: any = {};\n\n  if (typeof signal.buffer == \"undefined\") {\n    //signal is a normal array, convert to F32A\n    preparedSignal.signal = utilities.arrayToTyped(signal);\n  } else {\n    preparedSignal.signal = signal;\n  }\n\n  preparedSignal.windowedSignal = utilities.applyWindow(\n    preparedSignal.signal,\n    windowingFunction\n  );\n\n  preparedSignal.complexSpectrum = fft(preparedSignal.windowedSignal);\n  preparedSignal.ampSpectrum = new Float32Array(bufferSize / 2);\n  for (var i = 0; i < bufferSize / 2; i++) {\n    preparedSignal.ampSpectrum[i] = Math.sqrt(\n      Math.pow(preparedSignal.complexSpectrum.real[i], 2) +\n        Math.pow(preparedSignal.complexSpectrum.imag[i], 2)\n    );\n  }\n\n  return preparedSignal;\n};\n\n/**\n * The Meyda class\n * @type {Meyda}\n */\nexport default Meyda;\n\n// @ts-ignore\nif (typeof window !== \"undefined\") window.Meyda = Meyda;\n"],"names":["__spreadArray","to","from","pack","arguments","length","ar","i","l","Array","prototype","slice","call","concat","size","blackmanBuffer","Float32Array","coeff1","Math","PI","coeff2","cos","ceil","coeff","sineBuffer","sin","hanningBuffer","hammingBuffer","windows","isPowerOfTwo","num","applyWindow","signal","windowname","windowing","e","Error","a","b","c","min","pointwiseBufferMult","createBarkScale","sampleRate","bufferSize","barkScale","atan","pow","arrayToTyped","t","_freqToMel","freqValue","log","createMelFilterBank","numFilters","melValue","melValues","melValuesInFreq","upperLimitFreq","lowerLimitMel","valueToAdd","fftBinsOfFreq","exp","floor","filterBank","j","fill","createChromaFilterBank","centerOctave","octaveWidth","baseC","A440","numOutputBins","frequencyBins","map","_","freq","log2","hzToOctaves","emptyRow","colDenominators","binWidthBins","v","max","halfNumFilters","round","filterPeaks","frq","weights","row","reduce","acc","forEach","cell","sqrt","octaveWeights","mu","amplitudeSpect","numerator","denominator","k","abs","_a","ampSpectrum","TypeError","NUM_BARK_BANDS","specific","total","normalisedSpectrum","bbLimits","Int32Array","currentBandEnd","currentBand","sum","powerSpectrum","cosMap","dct","scale","L","N","PI_N","n","memoizeCosines","__","ix","prev","cur","ix_","arr","args","rms","energy","complexSpectrum","ampSum","freqSum","freqs","powFreqSum","ampFreqSum","curFreq","ampspec","nyqBin","ec","threshold","mu1","mu2","mu3","mu4","zcr","loudnessValue","loudness","spec","output","melFilterBank","numberOfMFCCCoefficients","_numberOfMFCCCoefficients","powSpec","extractPowerSpectrum","filtered","loggedMelBands","loggedMelBandsArray","chromaFilterBank","chromagram","maxVal","previousSignal","sf","x","_toConsumableArray","isArray","arr2","memoizedReversal","memoizedZeroBuffers","utils","bitReverseArray","undefined","maxBinaryLength","toString","templateBinary","repeat","reversed","currBinary","substr","reverse","join","parseInt","multiply","real","imag","add","subtract","euler","kn","conj","constructComplexArray","complexSignal","apply","Number","valueOf","fft","logN","bitReversedIndices","ordered","_i","currN","twiddle","m","currEvenIndex","currOddIndex","currEvenIndexSample","currOddIndexSample","odd","subtractionResult","additionResult","fft_1","options","_this","this","_m","audioContext","errors","noAC","utilities.isPowerOfTwo","_errors","notPow2","source","noSource","hopSize","callback","windowingFunction","featureExtractors","EXTRACTION_STARTED","startImmediately","channel","inputs","outputs","spn","createScriptProcessor","connect","destination","_featuresToExtract","utilities.createBarkScale","utilities.createMelFilterBank","melBands","inputData","previousInputData","frame","previousFrame","setSource","onaudioprocess","buffer","_this_1","inputBuffer","getChannelData","set","frameLength","hopLength","numFrames","utilities.frame","f","features","extract","MeydaAnalyzer","disconnect","console","error","Meyda","chromaBands","extractors","utilities.applyWindow","featureUndef","invalidFeatureFmt","invalidInput","createMeydaAnalyzer","Object","assign","listAvailableFeatureExtractors","keys","feature","utilities.createChromaFilterBank","utilities.arrayToTyped","preparedSignal","prepareSignalWithSpectrum","windowedSignal","preparedSignal_1","previousComplexSpectrum","previousAmpSpectrum","el","window"],"mappings":"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"}